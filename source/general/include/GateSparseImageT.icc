/*----------------------
  Copyright (C): OpenGATE Collaboration

  This software is distributed under the terms
  of the GNU Lesser General  Public Licence (LGPL)
  See GATE/LICENSE.txt for further details
  ----------------------*/


//-----------------------------------------------------------------------------
template<class PixelType>
GateSparseImageT<PixelType>::GateSparseImageT():GateVImage() {
  mInsideValue = 0;
  mOutsideValue = 0;
}
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
template<class PixelType>
GateSparseImageT<PixelType>::~GateSparseImageT() {
  data.clear();
}
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
template<class PixelType>
void GateSparseImageT<PixelType>::Allocate() {
  UpdateNumberOfValues();
  GateDebugMessage("Image",8,"GateSparseImageT::Resize " << nbOfValues << Gateendl);
  data.clear();
  // data.resize(nbOfValues);
  // std::fill(data.begin(), data.end(), 0.0);
  PrintInfo();
  UpdateDataForRootOutput();
}
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
template<class PixelType>
void GateSparseImageT<PixelType>::PrintInfo() {
  GateMessage("Image", 1, "Matrix Size=\t" << size        << Gateendl);
  GateMessage("Image", 1, "HalfSize=\t"    << halfSize    << Gateendl);
  GateMessage("Image", 1, "Resol=\t"       << resolution  << Gateendl);
  GateMessage("Image", 1, "VoxelSize=\t"   << voxelSize   << Gateendl);
  GateMessage("Image", 1, "planeSize=\t"   << planeSize   << Gateendl);
  GateMessage("Image", 1, "lineSize=\t"    << lineSize    << Gateendl);
  GateMessage("Image", 1, "nbOfValues=\t"  << nbOfValues  << Gateendl);
  GateMessage("Image", 1, "PixelSize=\t"   << sizeof(PixelType)  << Gateendl);
  GateMessage("Image", 1, "dataSize =\t"   << data.size() << Gateendl);
}
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
template<class PixelType>
void GateSparseImageT<PixelType>::Read(G4String filename) {
  G4String extension = getExtension(filename);

  if (extension == "txt") ReadAscii(filename);
  else if (extension == "hdr") ReadAnalyze(filename);
  else if (extension == "img") ReadAnalyze(filename);
  else if (extension == "img.gz") ReadAnalyze(filename);
  else if (extension == "mhd" || extension == "mha") ReadMHD(filename);
  else if (extension == "h33" || extension == "iff") ReadInterfile(filename);
  else if (extension == "i33") ReadInterfile(filename);
  else {
    GateError( "Unknow image file extension. Knowns extensions are : "
               << Gateendl << ".vox, .hdr, .img, .mhd, .mha, .h33, .i33\n");
    exit(0);
  }
}
//-----------------------------------------------------------------------------

template<class PixelType>
PixelType GateSparseImageT<PixelType>::FindMostCommonValue( typename const std::vector<PixelType>& temp){
  std::set<PixelType> vset(temp.begin(),temp.end());
  if ( vset.size() > 0.3 * temp.size() ){ // FIXME: is there a better way to catch non-sparse data?
    GateError("trying to read sparse matrix data from a source with too many different values: use a normal image instead of a sparse image!");
  }
  size_t ncommon=0;
  VoxelType common_value;
  for (typename std::set<PiVoxelType>::iterator ivset = vset.begin(); ivset != vset.end(); ++ivset){
    size_t n = std::count(temp.begin(),temp.end(),*ivset);
    if (n>ncommon){
      ncommon = n;
      common_value = *ivset;
    }
  }
  if ( ncommon < 0.5 * temp.size() ){ // FIXME: is there a better way to catch non-sparse data?
    GateError("trying to read sparse matrix data from a source with too few 'boring' values: use a normal image instead of a sparse image!");
  }
  return common_value;
}

template<class PixelType>
void GateSparseImageT<PixelType>::ConvertVectorToMap( typename std::vector<PixelType>& temp){
  mInsideValue = FindMostCommonValue(temp);
  data.clear();
  for (typename std::vector<PixelType>::iterator itmp = temp.begin(); itmp!=temp.end(); ++itmp){
    if (*itmp != mInsideValue){
      data.insert( std::make_pair(i,*itmp) );
    }
  }
}

template<class PixelType,class VoxelType>
void GateSparseImageT<PixelType>::GetRawDataFromFile<VoxelType>(istream& is){
  typename std::vector<VoxelType> temp1(nbOfValues);
  is.read((char*)(&(temp1[0])), nbOfValues*sizeof(VoxelType));
  typename std::vector<PixelType> temp2(nbOfValues);
  std::copy(temp1.begin(),temp1.end(),temp2.begin());
  temp.clear();
  ConvertVectorToMap(temp2);
}


//-----------------------------------------------------------------------------
template<class PixelType>
void GateSparseImageT<PixelType>::ReadAnalyze(G4String filename) {
  // Read header
  GateAnalyzeHeader hdr;
  hdr.Read(filename);

  short int rx,ry,rz,rc;
  hdr.GetImageSize(rx,ry,rz,rc);

  GateAnalyzeHeader::PixelType vx,vy,vz;
  hdr.GetVoxelSize(vx,vy,vz);

  // update sizes and allocate
  resolution = G4ThreeVector(rx,ry,rz);
  voxelSize = G4ThreeVector(vx,vy,vz);
  UpdateSizesFromResolutionAndVoxelSize();
  Allocate();

  // open .img file
  int l = filename.length();
  filename.replace(l-3,3,"img");
  std::ifstream is;
  OpenFileInput(filename, is);

  // Read values ...
  if (hdr.GetVoxelType() == GateAnalyzeHeader::SignedShortType) {
    GateMessage("Image",5,"Voxel Type = SignedShortType\n");
    GetRawDataFromFile<short>(istream& is);
  }
  else if (hdr.GetVoxelType() == GateAnalyzeHeader::FloatType) {
    GateMessage("Image",5,"Voxel Type = FloatType\n");
    GetRawDataFromFile<float>(istream& is);
  }
  else if (hdr.GetVoxelType() == GateAnalyzeHeader::SignedIntType) {
    GateMessage("Image",5,"Voxel Type = SignedIntType\n");
    GetRawDataFromFile<int>(istream& is);
  }
  else if (hdr.GetVoxelType() == GateAnalyzeHeader::UnsignedCharType) {
    GateMessage("Image",5,"Voxel Type = UnsignedCharType\n");
    GetRawDataFromFile<unsigned char>(istream& is);
  }
  else {
    GateError("I don't know (yet) this voxel type ... try float or unsigned char");
  }
}
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
template<class PixelType>
void GateSparseImageT<PixelType>::ReadMHD(G4String filename) {
  // Read mhd image
  GateMHDImage * mhd = new GateMHDImage;
  mhd->ReadHeader(filename);

  // Get image information
  resolution = G4ThreeVector(mhd->size[0], mhd->size[1], mhd->size[2]);
  voxelSize = G4ThreeVector(mhd->spacing[0], mhd->spacing[1], mhd->spacing[2]);
  origin = G4ThreeVector(mhd->origin[0], mhd->origin[1], mhd->origin[2]);

  // Convert mhd matrix to rotation matrix
  G4ThreeVector row_x, row_y, row_z;
  for(unsigned int i=0; i<3; i++) {
    row_x[i] = mhd->transform[i*3];
    row_y[i] = mhd->transform[i*3+1];
    row_z[i] = mhd->transform[i*3+2];
  }
  transformMatrix.setRows(row_x, row_y, row_z);
  if( !transformMatrix.row1().isNear(CLHEP::HepLorentzVector(row_x, 0.), 0.1) ||
      !transformMatrix.row2().isNear(CLHEP::HepLorentzVector(row_y, 0.), 0.1) ||
      !transformMatrix.row3().isNear(CLHEP::HepLorentzVector(row_z, 0.), 0.1) ) {
    GateError(filename << " contains a transformation which is not a rotation. "
              << "It is probably a flip and this is not handled.");
  }

  // We need to shift to half a pixel to be coherent with Gate
  // coordinates system. Must be transformed because voxel size is
  // known before rotation and origin is after rotation.
  origin -= transformMatrix*(voxelSize/2.0);
  UpdateSizesFromResolutionAndVoxelSize();
  Allocate();

  // Get image data
  typename std::vector<PixelType> temp(nbOfValues);
  mhd->ReadData(filename, temp);
  ConvertVectorToMap(temp);
}
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
template<class PixelType>
void GateSparseImageT<PixelType>::ReadInterfile(G4String filename) {
  // Read interfile image
  GateInterfileHeader * h33 = new GateInterfileHeader();
  h33->ReadHeader(filename);

  // Get image information
  voxelSize = G4ThreeVector(h33->m_pixelSize[0], h33->m_pixelSize[1], h33->m_planeThickness);
  resolution = G4ThreeVector(h33->m_dim[0], h33->m_dim[1], h33->m_numPlanes);

  // We need to shift to half a pixel to be coherent with Gate
  // coordinates system.
  origin[0] -= voxelSize[0]/2.0;
  origin[1] -= voxelSize[1]/2.0;
  origin[2] -= voxelSize[2]/2.0;
  origin = G4ThreeVector(origin[0], origin[1], origin[2]);
  UpdateSizesFromResolutionAndVoxelSize();
  Allocate();

  // Get image data
  typename std::vector<PixelType> temp(nbOfValues);
  h33->ReadData(temp);
  ConvertVectorToMap(temp);
}
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
template<class PixelType>
void GateSparseImageT<PixelType>::ReadAscii(G4String filename) {
  std::ifstream is;
  OpenFileInput(filename, is);

  // Header
  std::string s;
  is >> s ; //GateDebugMessage("Image",8,s<< Gateendl); // read ####################################
  is >> s ; //GateDebugMessage("Image",8,s<< Gateendl); // read #
  is >> s ; //GateDebugMessage("Image",8,s<< Gateendl); // read Matrix
  is >> s ; //GateDebugMessage("Image",8,s<< Gateendl); // read Size=
  is >> s ; //GateDebugMessage("Image",8,s<< Gateendl); // read values ...
  is >> s ; //GateDebugMessage("Image",8,s<< Gateendl); // read #
  is >> s ; //GateDebugMessage("Image",8,s<< Gateendl); // read Resol
  is >> s ; //GateDebugMessage("Image",8,s<< Gateendl); // read =
  G4ThreeVector resol;
  is >> resol;
  //GateDebugMessage("Image",8,"Resol = " << resol << Gateendl);
  is >> s ; //GateDebugMessage("Image",8,s<< Gateendl); // read #
  is >> s ; //GateDebugMessage("Image",8,s<< Gateendl); // read VoxelSize
  is >> s ;// GateDebugMessage("Image",8,s<< Gateendl); // read =
  G4ThreeVector voxsize;
  is >> voxsize;
  //GateDebugMessage("Image",8,"VoxelSize = " << voxsize << Gateendl);
  is >> s ; //GateDebugMessage("Image",8,s<< Gateendl); // read #
  is >> s ; //GateDebugMessage("Image",8,s<< Gateendl); // read nbVal
  is >> s ; //GateDebugMessage("Image",8,s<< Gateendl); // read =
  is >> s ; //GateDebugMessage("Image",8,s<< Gateendl); // read value
  is >> s ; //GateDebugMessage("Image",8,s<< Gateendl); // read ####################################

  // set size
  SetResolutionAndVoxelSize(resol, voxsize);
  Allocate();
  std::vector<PixelType> temp(nbOfValues);

  // read data
  int dim = 3;
  std::string v;
  if (resolution.x() == 1) dim--;
  if (resolution.y() == 1) dim--;
  if (resolution.z() == 1) dim--;
  //GateDebugMessage("Image",8,"Image dimension is " << dim << Gateendl);

  if (dim <= 1) {
    // read values in columns
    for(int i=0; i<nbOfValues; i++) {
      is >> v; //GateDebugMessage("Image",8,"val = " << v << Gateendl);
      temp[i] = atof(v.c_str()); //GateDebugMessage("Image",8,"val = " << temp[i] << Gateendl);
    }
  }
  if (dim == 2) {
    // write values in line/columns
    double width=0;
    double height=0;
    if (resolution.x() == 1.0) { width = resolution.y(); height = resolution.z(); }
    if (resolution.y() == 1.0) { width = resolution.x(); height = resolution.z(); }
    if (resolution.z() == 1.0) { width = resolution.x(); height = resolution.y(); }
    int i=0;
    for(int y=0; y<height; y++) {
      for(int x=0; x<width; x++) {
	is >> v;
	temp[i] = atof(v.c_str());
	i++;
      }
    }
  }
  if (dim == 3) {
    int i=0;
    for(int z=0; z<resolution.z(); z++) {
      for(int y=0; y<resolution.y(); y++) {
	for(int x=0; x<resolution.x(); x++) {
	  is >> v;
	  temp[i] = atof(v.c_str());
	  i++;
	}
      }
    }
  }
  if (!is) {
    //GateError( "Error while reading \n");
    exit(0);
  }
  ConvertVectorToMap(temp);
}
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
template<class PixelType>
void GateSparseImageT<PixelType>::MergeDataByAddition(G4String filename) {
  // check if it exist
  std::ifstream is(filename);
  if (!is) {
    return;
  }
  is.close();
  GateSparseImageT<PixelType> temp;
  temp.Read(filename);
  // maybe we should allow for rounding errors?
  if ( temp.GetOrigin() != origin ) GateError("trying to merge " << filename << " with origin=" << temp.GetOrigin() << " != " << origin << Gateendl);
  if ( temp.GetrResolution() != resolution ) GateError("trying to merge " << filename << " with resolution=" << temp.GetResolution() << " != " << resolution << Gateendl);
  if ( temp.GetrVoxelSize() != voxelsize ) GateError("trying to merge " << filename << " with voxelsize=" << temp.GetVoxelSize() << " != " << voxelSize << Gateendl);

  PixelType offset = temp.GetInsideValue();
  // this deals correctly with all voxels that are boring in both images
  mInsideValue += offset;
  for (iterator pi = data.begin(); pi != data.end(); ++pi) {
    // note: loops only over non-boring pixels in this image
    // this correctly takes care that are non-boring in this image and boring in the temp image
    pi->second+offset;
  }
  // now we added the offset to all pixels in 'this' image
  // for the non-boring pixels of the 'temp' we should 
  for (const_iterator pi = temp.begin(); pi != temp.end(); ++pi) {
    AddValue(pi->first,pi->second-offset);
    // AddValue correctly takes care of pixels where the sum of this and temp values equals the new boring value
  }
}
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
template<class PixelType>
void GateSparseImageT<PixelType>::Write(G4String filename, const G4String & comment){
  GateMessage("Actor",5,"GateSparseImageT::write " << filename << Gateendl);
  G4String extension = getExtension(filename);
  GateMessage("Actor",5,"extension = " << extension << Gateendl);

  std::ofstream os;
  if (extension == "bin") {
    // open
    OpenFileOutput(filename, os);
    WriteBin(os);
  }
  else {
     if (extension == "txt") {
      // open
      GateMessage("Actor",5,"Write text file"<< Gateendl);
      OpenFileOutput(filename, os);
      GateMessage("Actor",5,"Write text file"<< Gateendl);
      WriteAscii(os, comment);
      GateMessage("Actor",5,"Write text file - end \n");
    }
    else {
      if (extension == "hdr") {
        // Header
        GateAnalyzeHeader hdr;
        hdr.SetVoxelType(GateAnalyzeHeader::FloatType);
        hdr.SetImageSize((short int)resolution.x(),(short int)resolution.y(),(short int)resolution.z());
        hdr.SetVoxelSize((GateAnalyzeHeader::PixelType)voxelSize.x(),
                         (GateAnalyzeHeader::PixelType)voxelSize.y(),
                         (GateAnalyzeHeader::PixelType)voxelSize.z());
        hdr.Write(filename);
        // Data
        setExtension(filename,"img");
        // open
        OpenFileOutput(filename, os);
        WriteBin(os);
      }
      else {
        if (extension == "mhd" || extension == "mha") {
          WriteMHD(filename);
        }
        else {
          if (extension == "root") {
            WriteRoot(filename);
          }
          else {
            GateMessage("Image",0,"WARNING : Don't know how to write '" << extension
                        << " format... I try ASCII file\n");
            // open
            OpenFileOutput(filename, os);
            WriteAscii(os, comment);
          }
        }
      }
    }
  }
  os.close();
}
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
template<class PixelType>
void GateSparseImageT<PixelType>::WriteBin(std::ofstream & os)
{
  GateMessage("Image",2,"GateSparseImageT::WriteBin \n");
  // write
  // if PixelType is not float, we copy the values in a float vector
  if (typeid(PixelType) != typeid(float)) {
    std::vector<float>temp(nbOfValues);
    for(int i=0;i<nbOfValues;i++){
      temp[i]=(float)data[i]; // cast of PixelType to float
    }
    os.write((char*)(&(temp[0])), nbOfValues*sizeof(float));
  }
  else{
    os.write((char*)(&(data[0])), nbOfValues*sizeof(PixelType));
  }
  if (!os) {
    GateError( "Error while writing image data (WriteBin).\n");
  }
}
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
template<class PixelType>
void GateSparseImageT<PixelType>::WriteMHD(std::string filename)
{
  GateMessage("Image",2,"GateSparseImageT::WriteMHD \n");
  // Write mhd image
  GateMHDImage * mhd = new GateMHDImage;
  mhd->WriteHeader<PixelType>(filename, this);
  mhd->WriteData<PixelType>(filename, this);
}
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
template<class PixelType>
void GateSparseImageT<PixelType>::WriteAscii(std::ofstream & os, const G4String & comment)
{
  GateMessage("Image",2,"GateSparseImageT::WriteAscii \n");
  // write comment in header
  os  << "#################################### \n"
      << "# Matrix Size= " << size        << Gateendl
      << "# Resol      = " << resolution  << Gateendl
      << "# VoxelSize  = " << voxelSize   << Gateendl
      << "# nbVal      = " << nbOfValues  << Gateendl
      << "#################################### \n";
  if (comment != "") os << comment << Gateendl;

  // write data
  int dim = 3;
  if (resolution.x() == 1) dim--;
  if (resolution.y() == 1) dim--;
  if (resolution.z() == 1) dim--;
  GateMessage("Image",5,"Image dimension is " << dim << Gateendl);

  if (dim <= 1) {
    // write values in columns
    for(int i=0; i<nbOfValues; i++)
      os << std::setprecision(10) << data[i] << Gateendl;
  }
  if (dim == 2) {
    // write values in line/columns
    double width=0;
    double height=0;
    if (resolution.x() == 1.0) { width = resolution.y(); height = resolution.z(); }
    if (resolution.y() == 1.0) { width = resolution.x(); height = resolution.z(); }
    if (resolution.z() == 1.0) { width = resolution.x(); height = resolution.y(); }
    int i=0;
    for(int y=0; y<height; y++) {
      for(int x=0; x<width; x++) {
	os << data[i] << " ";
	i++;
      }
      os << Gateendl;
    }
  }
  if (dim == 3) {
    int i=0;
    for(int z=0; z<resolution.z(); z++) {
      for(int y=0; y<resolution.y(); y++) {
	for(int x=0; x<resolution.x(); x++) {
	  os << data[i] << " ";
	  i++;
	}
	os << Gateendl;
      }
      os << Gateendl;
    }
  }
  if (!os) {
    GateError( "WriteAscii: Error while writing ");
    exit(0);
  }
}
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
template<class PixelType>
void GateSparseImageT<PixelType>::WriteRoot(G4String filename)
{
  GateMessage("Image",2,"GateSparseImageT::WriteRoot \n");
#ifdef G4ANALYSIS_USE_ROOT
  // GateMessage("Image", 0 , "Writing image root output in " << filename << Gateendl);

  if (mRootHistoDim == 1) {
    TFile * f = new TFile(filename, "RECREATE");
    TH1F * h = new TH1F("histo",
			std::string("1D distribution "+filename).c_str(),
			mRootHistoBinxNb,
			mRootHistoBinxLow,
			mRootHistoBinxUp);
    double s = mRootHistoBinxSize/2.0;
    int i=0;
    for(double x=mRootHistoBinxLow+s; x<mRootHistoBinxUp; x+=mRootHistoBinxSize) {
      h->Fill(x, data[i]);
      i++;
    }
    h->Write();
    f->Close();
  }
  else if (mRootHistoDim == 2) {
    TFile * f = new TFile(filename, "RECREATE");
    TH2F * h2 = new TH2F("histo",
                         std::string("2D distribution "+filename).c_str(),
                         mRootHistoBinxNb,
                         mRootHistoBinxLow,
                         mRootHistoBinxUp,
                         mRootHistoBinyNb,
                         mRootHistoBinyLow,
                         mRootHistoBinyUp);
    double sx = mRootHistoBinxSize/2.0;
    double sy = mRootHistoBinySize/2.0;
    double x=mRootHistoBinxLow+sx;
    double y=mRootHistoBinyLow+sy;
    for(int i = 0;i<mRootHistoBinxNb;i++)
      {
        y=mRootHistoBinyLow+sy;
        for(int j = 0;j<mRootHistoBinyNb;j++)
          {
            h2->Fill(x,y, data[i*mRootHistoBinyNb+j]);
            y+=mRootHistoBinySize;
          }
        x+=mRootHistoBinxSize;
      }

    h2->Write();
    f->Close();
  }
  else {
    TFile * f = new TFile(filename, "RECREATE");
    TH3F * h3 = new TH3F("histo",
                         std::string("3D distribution "+filename).c_str(),
                         mRootHistoBinxNb,
                         mRootHistoBinxLow,
                         mRootHistoBinxUp,
                         mRootHistoBinyNb,
                         mRootHistoBinyLow,
                         mRootHistoBinyUp,
                         mRootHistoBinzNb,
                         mRootHistoBinzLow,
                         mRootHistoBinzUp);


    double sx = mRootHistoBinxSize/2.0;
    double sy = mRootHistoBinySize/2.0;
    double sz = mRootHistoBinzSize/2.0;
    double x=mRootHistoBinxLow+sx;
    double y=mRootHistoBinyLow+sy;
    double z=mRootHistoBinzLow+sz;
    for(int i = 0;i<mRootHistoBinxNb;i++)
      {
        y=mRootHistoBinyLow+sy;
        for(int j = 0;j<mRootHistoBinyNb;j++)
          {
            z=mRootHistoBinzLow+sz;
            for(int k = 0;k<mRootHistoBinzNb;k++)
              {

                h3->Fill(x,y,z, data[k*mRootHistoBinxNb*mRootHistoBinyNb+ j*mRootHistoBinxNb+i]);
                z+=mRootHistoBinzSize;

              }
            y+=mRootHistoBinySize;
          }
        x+=mRootHistoBinxSize;

        h3->Write();

      }

    f->Close();
  }

#endif
#ifndef G4ANALYSIS_USE_ROOT
  GateError(filename<<" was not created. GATE was compiled without ROOT!");
#endif


}
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
template<class PixelType>
PixelType
GateSparseImageT<PixelType>::GetNeighborValueFromCoordinate(const ESide & side, const G4ThreeVector & coord)
{
  G4ThreeVector c(coord);
  switch (side) {
  case kMX:c.setX(coord.x()-1); break;
  case kPX:c.setX(coord.x()+1); break;
  case kMY:c.setY(coord.y()-1); break;
  case kPY:c.setY(coord.y()+1); break;
  case kMZ:c.setZ(coord.z()-1); break;
  case kPZ:c.setZ(coord.z()+1); break;
  default: break;
    //	GateError("I don't know side = " << side);
  }
  return GetValue(GetIndexFromCoordinates(c));
}
//-----------------------------------------------------------------------------

template<class PixelType>
PixelType
GateSparseImageT<PixelType>::GetMinValue() const{
  return (data.empty() ? mInsideValue : std::min(mInsideValue,std::min_element(begin(), end(), second_less<PixelType>)->second));
}

template<class PixelType>
PixelType
GateSparseImageT<PixelType>::GetMaxValue() const{
  return (data.empty() ? mInsideValue : std::max(mInsideValue,std::max_element(begin(), end(), second_less<PixelType>)->second));
}

template<class PixelType>
PixelType
GateSparseImageT<PixelType>::GetValue(int i, int j, int k) const {
  const_iterator idata = data.find(GetIndex(i,j,k));
  return (idata != data.end() ) ? idata->second : mInsideValue;
}

// vim: ai sw=2 ts=2 et filetype=cpp
